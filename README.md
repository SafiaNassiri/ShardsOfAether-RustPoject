# Shards of Aether

A text-based adventure RPG written in **Rust**, featuring exploration, turn-based combat, and dynamic world progression through multiple JSON-defined maps.

## Game Overview

**Shards of Aether** is a command-line adventure game where the player explores interconnected levels, battles enemies, collects relics, and uncovers the fate of a fractured world.

Each area is defined in structured **JSON** files that load dynamically, allowing smooth transitions between levels while preserving the player‚Äôs progress and inventory. The gameplay emphasizes strategic combat choices, exploration, and resource management.

### Core Features

- **JSON-Based World System**  
  Every level (map) is defined as a JSON file containing rooms, items, exits, and enemies. The engine dynamically loads and unloads these maps when transitioning between levels.  
  Rooms have coordinates (`x`, `y`) that allow for future map rendering and procedural expansion.

- **Turn-Based Combat System**  
   Engage enemies using simple text commands:
  attack / heal / defend / run
  The system is **turn-driven** ‚Äî enemies only attack after a valid player move, preventing damage from typos or invalid input.

Each victory grants XP, scaling with enemy strength, and lets the player progress further into the world.

- **Command Parsing & Input Handling**  
  The command system parses raw text input into structured enums like `Command::Go`, `Command::Use`, `Command::Look`, etc.  
  This structure allows easily adding new commands or interactions (e.g. puzzles, special actions).

- **Player Progress & Inventory System**  
  The player‚Äôs data ‚Äî health, inventory, XP, and current room ‚Äî is stored persistently between levels.  
  Items are typed (`Healing`, `Weapon`, `Quest`, `Utility`) to enable flexible in-game effects.

- **Level Transitions via JSON Loading**  
  When entering certain rooms (like ‚ÄúSanctum‚Äù), the game seamlessly loads the next map file and repositions the player.  
  Player inventory, health, and XP remain intact across transitions.

- **Dynamic Map Rendering**  
  The world map is generated by reading the `x` and `y` coordinates of each room, then printing a simplified ASCII minimap showing where the player currently is.  
  This approach uses computed bounds (`min_x`, `max_x`, etc.) to scale automatically for any map layout.

## Gameplay Example

```text
You are standing in a grand hall with a glittering chandelier.
Exits: north ‚Üí library, east ‚Üí kitchen

> go north
You move north.
üßç You have entered: river_bridge
river_bridge

A fragile wooden bridge spans the river. You hear rustling in the bushes.
Exits: west, south
‚ö†Ô∏è You sense danger nearby... (Goblin)

‚öîÔ∏è A wild Goblin appears!
‚öîÔ∏è You encounter a Goblin!
A sneaky little creature with a rusty dagger.

‚ù§Ô∏è Your HP: 4 | üíÄ Goblin‚Äôs HP: 20
Choose an action (attack / heal / defend / run):
> defend
üõ°Ô∏è You brace yourself!
The Goblin attacks you for 4 damage!

```

If your HP reaches 0, the game displays a death ASCII art screen and exits dramatically:

```text
üíÄ You have been defeated!

‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚†Ä‚†Ä‚†Ä‚£∂‚°Ü‚†Ä‚£∞‚£ø‚†á‚£æ‚°ø‚†õ‚†â‚†Å
‚†Ä‚£†‚£¥‚†æ‚†ø‚†ø‚†Ä‚¢Ä‚£æ‚£ø‚£Ü‚£Ä‚£∏‚£ø‚£∑‚£æ‚£ø‚°ø‚¢∏‚£ø‚†ü‚¢ì‚†Ä‚†Ä
‚£¥‚°ü‚†Å‚£Ä‚£†‚£§‚†Ä‚£º‚£ø‚†æ‚£ø‚£ª‚£ø‚†É‚†ô‚¢´‚£ø‚†É‚£ø‚°ø‚†ü‚†õ‚†Å‚†Ä
‚¢ø‚£ù‚£ª‚£ø‚°ø‚†ã‚†æ‚†ü‚†Å‚†Ä‚†π‚†ü‚†õ‚†Ä‚†Ä‚†à‚†â‚†Ä‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†â‚†â‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ä‚†Ä‚†Ä‚£Ä‚¢Ä‚£†‚£§‚£¥‚£§‚£Ñ‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£§‚£§‚¢∂‚£§‚†Ä‚†Ä‚¢Ä‚£¥‚¢É‚£ø‚†ü‚†ã‚¢π‚£ø‚££‚£¥‚°ø‚†ã‚†Ä
‚†Ä‚†Ä‚£∞‚£æ‚†ü‚†â‚£ø‚°ú‚£ø‚°Ü‚£¥‚°ø‚†Å‚£º‚°ø‚†õ‚¢É‚£æ‚°ø‚†ã‚¢ª‚£á‚†Ä‚†Ä
‚†Ä‚†ê‚£ø‚°Å‚¢Ä‚£†‚£ø‚°á‚¢π‚£ø‚°ø‚†Å‚¢†‚£ø‚†∑‚†ü‚†ª‚†ü‚†Ä‚†Ä‚†à‚†õ‚†Ä‚†Ä
‚†Ä‚†Ä‚†ô‚†ª‚†ø‚†ü‚†ã‚†Ä‚†Ä‚†ô‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä

Game Over. Thanks for playing Adventurer!
Another shall be sent to complete what you have failed in.
```

## Technical Overview

### JSON Data Structure

Each level file (level1.json, sanctum.json, etc.) follows this structure:

```json
{
  "rooms": {
    "hall": {
      "id": "hall",
      "description": "You are standing in a grand hall with a glittering chandelier.",
      "items": [
        {
          "name": "rusty key",
          "description": "An old, rusty key. I wonder what it opens."
        }
      ],
      "exits": { "north": "library", "east": "kitchen" },
      "x": 0,
      "y": 0
    }
  }
}
```

The engine deserializes these into Room structs using serde:

```rust
#[derive(Serialize, Deserialize, Clone)]
pub struct Room {
    pub id: String,
    pub description: String,
    #[serde(default)] pub items: Vec<Item>,
    #[serde(default)] pub exits: HashMap<String, String>,
    #[serde(default)] pub enemy: Option<String>,
    #[serde(default)] pub x: i32,
    #[serde(default)] pub y: i32,
}
```

This makes missing fields safe by using #[serde(default)], avoiding crashes from incomplete JSON.

### Tech Stack

- Language: Rust ü¶Ä
- Serialization: serde
- Persistence: JSON map files
- CLI Input: std::io utilities
- Game State: Struct-based, with enums for Command, ItemType, and EnemyType

### Running the Game

1. Clone the project

```bash
git clone https://github.com/yourusername/shards_of_aether.git
cd shards_of_aether
```

2. Build and run

```bash
cargo build
cargo run
```

3. Explore!
   Use commands like:

```text
go north
status
look
inventory
use potion
save
load
quit
```

# License

This project is licensed under the MIT License.
